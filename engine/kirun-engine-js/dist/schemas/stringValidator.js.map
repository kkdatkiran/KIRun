{"version":3,"sources":["../../src/schemas/stringValidator.js"],"names":["TIME","RegExp","DATE","DATETIME","stringValidator","parents","schema","schemaRepository","functionRepository","element","validate","title","format","patternMatcher","pattern","minLength","length","maxLength","regex","message","match"],"mappings":";;;;;;;AAAA;;AAEA,IAAMA,IAAI,GAAG,IAAIC,MAAJ,CAAW,2EAAX,CAAb;AAEA,IAAMC,IAAI,GAAG,IAAID,MAAJ,CAAW,4DAAX,CAAb;AAEA,IAAME,QAAQ,GAAG,IAAIF,MAAJ,CAAW,+DAA+D,0EAA1E,CAAjB;;AAEe,SAASG,eAAT,CAAyBC,OAAzB,EAAkCC,MAAlC,EAA0CC,gBAA1C,EAA4DC,kBAA5D,EAAgFC,OAAhF,EAAyFC,QAAzF,EAAmG;AAChH,MAAI,CAACD,OAAD,IAAY,OAAOA,OAAP,KAAmB,QAAnC,EAA6C,gBAAS,qBAAKJ,OAAL,EAAcC,MAAM,CAACK,KAArB,CAAT,qCAA+DF,OAA/D;;AAE7C,MAAIH,MAAM,CAACM,MAAP,KAAkB,MAAtB,EAA8B;AAC5BC,IAAAA,cAAc,CAACR,OAAD,EAAUC,MAAV,EAAkBG,OAAlB,EAA2BT,IAA3B,EAAiC,cAAjC,CAAd;AACD,GAFD,MAEO,IAAIM,MAAM,CAACM,MAAP,KAAkB,MAAtB,EAA8B;AACnCC,IAAAA,cAAc,CAACR,OAAD,EAAUC,MAAV,EAAkBG,OAAlB,EAA2BP,IAA3B,EAAiC,cAAjC,CAAd;AACD,GAFM,MAEA,IAAII,MAAM,CAACM,MAAP,KAAkB,UAAtB,EAAkC;AACvCC,IAAAA,cAAc,CAACR,OAAD,EAAUC,MAAV,EAAkBG,OAAlB,EAA2BN,QAA3B,EAAqC,mBAArC,CAAd;AACD,GAFM,MAEA,IAAIG,MAAM,CAACQ,OAAP,KAAmB,IAAvB,EAA6B;AAClCD,IAAAA,cAAc,CAACR,OAAD,EAAUC,MAAV,EAAkBG,OAAlB,EAA2B,IAAIR,MAAJ,CAAWK,MAAM,CAACQ,OAAlB,CAA3B,EAAuD,aAAaR,MAAM,CAACQ,OAA3E,CAAd;AACD;;AAED,MAAIR,MAAM,CAACS,SAAP,IAAoBN,OAAO,CAACO,MAAR,GAAiBV,MAAM,CAACS,SAAhD,EAA2D;AACzD,oBAAS,qBAAKV,OAAL,EAAcC,MAAM,CAACK,KAArB,CAAT,mCAA6DL,MAAM,CAACS,SAApE;AACD,GAFD,MAEO,IAAIT,MAAM,CAACW,SAAP,IAAoBR,OAAO,CAACO,MAAR,GAAiBV,MAAM,CAACW,SAAhD,EAA2D;AAChE,oBAAS,qBAAKZ,OAAL,EAAcC,MAAM,CAACK,KAArB,CAAT,mCAA6DL,MAAM,CAACW,SAApE;AACD;AACF;;AAED,SAASJ,cAAT,CAAwBR,OAAxB,EAAiCC,MAAjC,EAAyCG,OAAzC,EAAkDS,KAAlD,EAAyDC,OAAzD,EAAkE;AAChE,MAAIV,OAAO,CAACW,KAAR,CAAcF,KAAd,CAAJ,EAA0B;AAE1B,kBAAS,qBAAKb,OAAL,EAAcC,MAAM,CAACK,KAArB,CAAT,SAAuCF,OAAvC,sCAA0EU,OAA1E;AACD","sourcesContent":["import { path } from \"./constants\";\n\nconst TIME = new RegExp(\"^([01]?[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?([+-][01][0-9]:[0-5][0-9])?$\");\n\nconst DATE = new RegExp(\"^[0-9]{4,4}-([0][0-9]|[1][0-2])-(0[1-9]|[1-2][1-9]|3[01])$\");\n\nconst DATETIME = new RegExp(\"^[0-9]{4,4}-([0][0-9]|[1][0-2])-(0[1-9]|[1-2][1-9]|3[01])T\" + \"([01]?[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?([+-][01][0-9]:[0-5][0-9])?$\");\n\nexport default function stringValidator(parents, schema, schemaRepository, functionRepository, element, validate) {\n  if (!element || typeof element !== \"string\") throw `${path(parents, schema.title)}Expected a string found ${element}`;\n\n  if (schema.format === \"TIME\") {\n    patternMatcher(parents, schema, element, TIME, \"time pattern\");\n  } else if (schema.format === \"DATE\") {\n    patternMatcher(parents, schema, element, DATE, \"date pattern\");\n  } else if (schema.format === \"DATETIME\") {\n    patternMatcher(parents, schema, element, DATETIME, \"date time pattern\");\n  } else if (schema.pattern !== null) {\n    patternMatcher(parents, schema, element, new RegExp(schema.pattern), \"pattern \" + schema.pattern);\n  }\n\n  if (schema.minLength && element.length < schema.minLength) {\n    throw `${path(parents, schema.title)}Expected a minimum of ${schema.minLength} characters`;\n  } else if (schema.maxLength && element.length > schema.maxLength) {\n    throw `${path(parents, schema.title)}Expected a maximum of ${schema.maxLength} characters`;\n  }\n}\n\nfunction patternMatcher(parents, schema, element, regex, message) {\n  if (element.match(regex)) return;\n\n  throw `${path(parents, schema.title)}${element} is not matched with the ${message}`;\n}\n"],"file":"stringValidator.js"}